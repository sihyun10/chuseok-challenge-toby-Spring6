## 10월 2일 챌린지 첫 시작

추석 연휴에 향로님이 함께하는 완강 챌린지를 열었다는 소식을 듣고,  
함께 하고 싶단 생각이 들어 바로 고민 1도 안하고 신청하였다.

강의를 구매한 후에 챌린지 기간 동안 완강하는 것을 목표로 한다.  
10일간 내가 완강을 할 수 있고, 나에게 도움이 되는 강의를 고르고 싶었다.  
현재 내가 듣고 있는건 `스프링 MVC 2편 - 백엔드 웹 개발 활용 기술` 영한님 강의이고, 내가 구매를 안했었던 강의 중에 골라야했었다. 영한님 강의를 쭉 이어서 듣고 싶었지만, 이미 나에겐 다 구매가 되어있었다.

따라서 현재 내가 공부하고 있는 **스프링** 관련 강의를 찾고자 했다.  
그때 마침 `토비의 스프링6` 강의를 발견하게 되었고, 강의 소개 영상을 보며 스프링과 관련해서 많은 생각을 해볼 수 있을 것 같았고, 동작 원리에 대해 깊이 고민하는 시간을 가져야겠다고 생각하였다.

그렇게 이 강의를 결정하게 되었고,  
앞으로의 챌린지 기간 동안 열심히 강의를 들으며, 사고의 폭을 넓혀가야겠다

---

### 강의 첫 시작

오늘은 가볍게 시작했기에 강의 소개 & 프로젝트 환경 설정, 요구사항에 맞게 `PaymentService` 개발을 간단하게 해보았다. 강의를 들으며 토비님의 스타일을 알게 되었다. 하나하나 알려주시면서 `이땐 어떤걸 사용해야할까요?` 하시면서 고민거리를 던져주고, 답을 알려주는 방식으로 강의를 진행하신다.

---

오늘 알아가는 지식은 다음과 같다.

### 자바의 `record` (자바 16에서 정식으로 추가된 문법)

`record`를 사용하면 한 줄이면 끝이다.

```java
@JsonIgnoreProperties(ignoreUnknown = true)
public record ExRateData(String result, Map<String, BigDecimal> rates) {}
```

이와 같이 작성하면 컴파일러가 자동으로 다음을 만들어준다.

- `private final` 필드
- 모든 필드를 받는 생성자
- getter 대신 `필드명()` 메서드
- `toString()`, `equals()`, `hashCode()`

즉, 불변 객체를 위한 기본 코드들을 자동으로 생성해준다.

#### (예시)

```java
public final class ExRateData {
    private final String result;
    private final Map<String, BigDecimal> rates;

    // 모든 필드를 받는 생성자
    public ExRateData(String result, Map<String, BigDecimal> rates) {
        this.result = result;
        this.rates = rates;
    }

    // getter 대신 필드명() 메서드
    public String result() {
        return result;
    }

    public Map<String, BigDecimal> rates() {
        return rates;
    }

    // toString()
    @Override
    public String toString() {
        return "ExRateData[result=" + result + ", rates=" + rates + "]";
    }

    // equals()
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof ExRateData)) return false;
        ExRateData that = (ExRateData) o;
        return Objects.equals(result, that.result) &&
               Objects.equals(rates, that.rates);
    }

    // hashCode()
    @Override
    public int hashCode() {
        return Objects.hash(result, rates);
    }
}
```

<br>

### 왜 BigDecimal을 써야할까?

**1. double의 문제점**

- `double`은 부동소수점 방식으로 숫자를 표현
- 2진수로 숫자를 표현하기 때문에, 10진수 기반의 금액을 정확히 표현하지 못한다

```java
double a = 0.1;
double b = 0.2;
System.out.println(a + b); // 0.30000000000000004 출력
```

➔ 금융 계산에서 이와 같은 작은 오차도 큰 문제가 된다.

**2. BigDecimal의 장점**

- 정확한 10진수 계산
- 반올림, 올림, 버림 등 금융에 필요한 다양한 연산 모드 제공
- 크기가 큰 숫자도 다룰 수 있음

금액과 같이 정확한 계산을 해야하는 서비스의 경우,  
`BigDecimal`을 필수적으로 사용해야한다고 하셨다.

---

내일은 오브젝트와 의존관계에 대해서 배울텐데, 어떤걸 배울지 궁금하다.  
저녁 8시에 라이브 방송을 보고 난 후, 강의를 듣기 시작했기에 오늘 글 작성이 조금 늦어졌다.  
내일부터는 늦지않게 잘 작성할 수 있도록 해야겠다.

향로님이 보내주신 말씀을 끝으로 오늘 글은 마무리해야겠다.

![향로님의 챌린지 첫 시작 말씀](/assets/img/challenge.jpeg)
