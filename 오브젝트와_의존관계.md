## 10월 3일 "객체지향 설계원칙을 코드로 체감해보기"

오브젝트와 의존관계를 시작으로, 관심사의 분리, 상속을 통한 확장, 클래스의 분리, 인터페이스 도입, 관계설정 책임 분리, 오브젝트 팩토리, 원칙과 패턴까지 이어지는 객체지향 설계의 기본 원칙들을 학습하였다.

강의 내용을 따라가면서 "객체지향 프로그래밍에서 왜 이런 개념들이 중요한지"를 이해할 수 있었다.

---

### 상속을 통한 확장

강의 예제에서는 환율 정보를 다루는 `PaymentService`가 등장한다.  
환율 계산이라는 기본 틀은 동일하지만, 환율을 가져오는 방식에 따라 확장이 가능하다.

```java
PaymentService paymentService = new SimpleExRatePaymentService();
// 또는
PaymentService paymentService = new WebApiExRatePaymentService();
```

- SimpleExRatePaymentService : 하드코딩된 환율을 반환
- WebApiExRatePaymentService : 외부 API를 호출해 환율을 받아온다

상속을 이용하면 환율 정보를 가져오는 로직만 다르게 구현할 수 있다.  
예를 들어 `SimpleExRatePaymentService()`, `WebApiExRatePaymentService()`를 갈아끼우면 된다.

```java
public class Client {
  public static void main(String[] args) throws IOException {
    PaymentService paymentService = new SimpleExRatePaymentService();
    Payment payment = paymentService.prepare(100L, "USD", BigDecimal.valueOf(50.7));
    System.out.println(payment);
  }
}
```

클라이언트 입장에서는 `PaymentService`라는 동일한 타입을 사용하므로, 재사용성이 높아진다.  
단점으로는 상위 클래스 코드가 변경되면, 이를 상속받은 모든 하위 클래스들이 영향을 받는다.  
또 확장 기능이 많아질수록 복잡성이 증가한다. 기능마다 상속 클래스를 새로 만들어야 하기 때문에 클래스 수가 점점 늘어나게 된다.

그래서 상속만으로는 한계가 있다.

---

### 클래스의 분리

이 문제를 해결하기 위해 관심사를 아예 다른 클래스로 분리한다.

- PaymentService : 결제를 준비하는 역할만 담당
- ExRateProvider : 환율 정보를 가져오는 역할만 담당

```java
public class PaymentService {
  private final WebApiExRateProvider exRateProvider;

  public PaymentService() {
    this.exRateProvider = new WebApiExRateProvider();
  }

  public Payment prepare(Long orderId, String currency, BigDecimal foreignCurrencyAmount) throws IOException {
    BigDecimal exRate = exRateProvider.getWebExRate(currency);
    BigDecimal convertedAmount = foreignCurrencyAmount.multiply(exRate);
    LocalDateTime validUntil = LocalDateTime.now().plusMinutes(30);

    return new Payment(orderId, currency, foreignCurrencyAmount, exRate, convertedAmount, validUntil);
  }
}
```

- final 키워드를 붙이는 이유는 한 번 할당된 후 변경되지 않음을 보장하기 위해서이다.

하지만 이 코드에도 문제가 있다.  
만약 환율 제공 방식을 `SimpleExRateProvider`로 바꾸고 싶다면?

```java
private final SimpleExRateProvider exRateProvider;

public PaymentService() {
  this.exRateProvider = new SimpleExRateProvider();
}
```

결국 PaymentService 코드 자체를 수정해야한다.

---

### 인터페이스 도입

앞서 `PaymentService`는 `WebApiExRateProvider`나 `SimpleExRateProvider` 같은 **구체 클래스에 강하게 결합**되어 있었다.  
그렇기에 환율 제공 방식을 바꾸려면 `PaymentService` 코드를 직접 수정해야 했다.

이 문제를 해결하기 위해 **인터페이스**를 도입한다!

```java
public interface ExRateProvider {
  BigDecimal getExRate(String currency) throws IOException;
}
```

그리고 실제 구현체는 이 인터페이스를 구현하도록 만든다.

```java
public class SimpleExRateProvider implements ExRateProvider {
  @Override
  public BigDecimal getExRate(String currency) throws IOException {
    if (currency.equals("USD")) {
      return BigDecimal.valueOf(1000);
    }
    throw new IllegalArgumentException("지원되지 않는 통화입니다");
  }
}
```

이제 `PaymentService`는 구현체가 아니라 인터페이스에 의존한다.

```java
public class PaymentService {
    private final ExRateProvider exRateProvider;

    public PaymentService() {
        this.exRateProvider = new WebApiExRateProvider();
    }

    public Payment prepare(Long orderId, String currency, BigDecimal foreignCurrencyAmount) throws IOException {
        BigDecimal exRate = exRateProvider.getExRate(currency);
        BigDecimal convertedAmount = foreignCurrencyAmount.multiply(exRate);
        LocalDateTime validUntil = LocalDateTime.now().plusMinutes(30);

        return new Payment(orderId, currency, foreignCurrencyAmount, exRate, convertedAmount, validUntil);
    }
}
```

이제 환율 제공방식을 바꾸고 싶다면 `new WebApiExRateProvider()` 부분만 변경하면 된다.

```java
public PaymentService() {
  this.exRateProvider = new WebApiExRateProvider();
}
```

---

### 관계설정 책임의 분리

지금도 `PaymentService` 안에서 `WebApiExRateProvider`를 직접 생성하고 있다.

이를 개선하기 위해 **의존관계 설정 책임을 외부로 분리**한다.  
즉, `PaymentService`는 어떤 구현체가 주어질지만 알면 되고, 실제 객체를 누가 넣어줄지는 바깥에서 결정한다.

```java
public class PaymentService {
  private final ExRateProvider exRateProvider;

  public PaymentService(ExRateProvider exRateProvider) {
    this.exRateProvider = exRateProvider;
  }

  public Payment prepare(Long orderId, String currency, BigDecimal foreignCurrencyAmount) throws IOException {
    BigDecimal exRate = exRateProvider.getExRate(currency);
    BigDecimal convertedAmount = foreignCurrencyAmount.multiply(exRate);
    LocalDateTime validUntil = LocalDateTime.now().plusMinutes(30);

    return new Payment(orderId, currency, foreignCurrencyAmount, exRate, convertedAmount, validUntil);
  }
}
```

이제 어떤 환율 제공자를 쓸지는 클라이언트 코드에서 결정한다.

```java
public class Client {
  public static void main(String[] args) throws IOException {
    PaymentService paymentService = new PaymentService(new WebApiExRateProvider());
    Payment payment = paymentService.prepare(100L, "USD", BigDecimal.valueOf(50.7));
    System.out.println(payment);
  }
}
```

그럼 `PaymentService` 코드는 더 이상 수정할 필요가 없다.

---

### 오브젝트 팩토리

하지만 Client 코드도 문제를 갖고 있다.

2가지 책임을 동시에 가지고 있기 때문이다.

1. 어떤 구현체를 조합해서 사용할지 "관계 설정"
2. 실제 `PaymentService`를 이용해서 로직을 수행

이 2가지 관심사를 분리하기 위해 **오브젝트 팩토리**를 도입한다.

```java
public class ObjectFactory {
  public PaymentService paymentService() {
    return new PaymentService(exRateProvider());
  }

  public ExRateProvider exRateProvider() {
    return new WebApiExRateProvider(); // 여기만 수정해주면 된다.
  }
}
```

이제 `Client`는 `ObjectFactory`가 만들어준 객체를 사용하기만 하면 된다.

```java
public class Client {
  public static void main(String[] args) throws IOException {
    ObjectFactory objectFactory = new ObjectFactory();
    PaymentService paymentService = objectFactory.paymentService();

    Payment payment = paymentService.prepare(100L, "USD", BigDecimal.valueOf(50.7));
    System.out.println(payment);
  }
}
```

`Client`는 비즈니스 로직만 신경 쓰고, 어떤 구현체를 조합해서 사용할지는 `ObjectFactory`가 담당한다.

---

### 마무리

코드 구조를 점차 개선해나가며, 자연스럽게 객체지향 설계원칙과 디자인 패턴을 몸소 느껴보았다.  
좋은 코드 구조는 한 번에 완성되는 것이 아닌 점진적으로 개선되는 과정 속에서 나온다는 것이었다.

처음에는 단순히 동작하는 코드를 짰었는데,  
관심사 분리, 클래스 분리, 인터페이스 도입, 관계설정 책임의 분리, 오브젝트 팩토리를 도입 등 순차적으로 개선해나가며 토비님이 전달하고 싶은 '객체지향'에 대해 느낄 수 있었다.

그리고 이런 원칙과 패턴들을 매번 내가 직접 구현하지 않아도 되도록 스프링은 프레임워크 차원에서 이미 지원해주고 있었다. 그래서 스프링을 쓰면, 자연스럽게 좋은 설계 원칙이 코드 안에 녹아든다.

'아, 이래서 사람들이 스프링을 많이 쓰는구나' 생각이 들었다.

<br>

이제 본격적으로 스프링 컨테이너와 의존관계 주입 등을 배우게 될텐데,  
영한님께서 알려주신 내용도 복귀가 되면서 아직도 넓게 보는 눈이 길러지지 않았다는걸 깨달았다.

오늘 배운 내용을 가볍게 다시 읽어보고 자야겠다.  
많은 사람들이 함께 공부하고 있다는 생각이 드니까 힘이 나면서 공부하는데에 지루하지가 않았다.  
(챌린지를 함께 하는 분들과 있는 톡방이 엄청 활발하기 때문이다ㅋㅋㅋㅋ)

다들 쉬는 날임에도 불구하고, 각자의 자리에서 열심히 하고 계시는걸 보며  
나 또한 열심히 해야겠다고 느꼈다ㅎㅎ
